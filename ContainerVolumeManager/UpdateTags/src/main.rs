///////////////////////////////////////////////////////////////////////////////
// NAME:             main.rs
//
// AUTHOR:           Ethan D. Twardy <edtwardy@mtu.edu>
//
// DESCRIPTION:      Easily update the tags file for a volume image.
//
// CREATED:          06/27/2021
//
// LAST EDITED:      07/02/2021
///

use std::collections::HashMap;
use std::env;
use std::fs::File;
use std::io::{self, BufRead, Write};
use std::path::Path;
use std::process;

const IMAGE_SUFFIX: &str = "-volume.tar.gz";
const COLUMNS: usize = 2;
const TAGS_FILE_NAME: &str = "tags";
const NUMBER_OF_ARGUMENTS: usize = 2;
const COLUMN_ALIGNMENT: usize = 4;
const USAGE: &str = "\
<tag> <volumeImage>\n\
\n\
Where <tag> is the new tag of <volumeImage>. The tags file is discovered\n\
automatically.\
";

const TAGS_FILE_HEADER: &str = "\
# This file was auto-generated by the Container Volume Manager. Preferably, \n\
# it isn't edited by hand.\n\
";

fn update_tags(tag: &str, volume_image: &Path) -> io::Result<()> {
    let tags_filepath = volume_image.parent().unwrap().join(TAGS_FILE_NAME);
    let mut image_tags: HashMap<String, String> = HashMap::new();
    if tags_filepath.exists() {
        let tags_file = io::BufReader::new(File::open(&tags_filepath)?).lines()
            .map(|l| l.unwrap());
        for line in tags_file {
            let trimmed = line.trim();
            let entry: Vec<&str> = match trimmed.chars().nth(0) {
                None => continue,
                Some('#') => continue,
                Some(_) => trimmed.split_whitespace().collect::<Vec<&str>>(),
            };

            assert_eq!(entry.len(), COLUMNS,
                       "wrong number of columns in entry: {:?} (expected {})",
                       entry, COLUMNS);
            image_tags.insert(entry[0].to_string(), entry[1].to_string());
        }
    }

    let volume_name = str::replace(
        volume_image.file_name().unwrap().to_str().unwrap(), IMAGE_SUFFIX, ""
    );

    *image_tags.entry(volume_name).or_insert(String::new()) = tag.to_string();

    // Get the longest string (for alignment)
    let mut longest_tag: usize = 0;
    for (name, _) in image_tags.iter() {
        if name.len() > longest_tag {
            longest_tag = name.len();
        }
    }
    let longest_tag = longest_tag + (COLUMN_ALIGNMENT
                                   - (longest_tag % COLUMN_ALIGNMENT));

    let mut tags_file = File::create(&tags_filepath)?;
    tags_file.write_all(TAGS_FILE_HEADER.as_bytes())?;
    tags_file.write_all(
        image_tags.drain()
            .map(|(name, tag)| format!("{:<longest_tag$}{}", name, &tag,
                                       longest_tag=longest_tag))
            .collect::<Vec<String>>().join("\n").as_bytes()
    )?;
    Ok(())
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != NUMBER_OF_ARGUMENTS + 1 {
        eprintln!("{} {}", &args[0], USAGE);
        process::exit(1);
    }

    let volume_image = Path::new(&args[2]);
    if !volume_image.exists() {
        eprintln!("Error: {}: No such file or directory.",
                  volume_image.display());
        process::exit(1);
    }

    process::exit(match update_tags(&args[1], &volume_image) {
        Ok(_) => 0,
        Err(_) => 1,
    });
}

///////////////////////////////////////////////////////////////////////////////
